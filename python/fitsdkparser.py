#!/usr/bin/env python3
#
# This utility will generate the swift code from the c Fit SDK
#   You can download the Fit SDK from https://developer.garmin.com/fit and update your local copy using the diffsdk.py script
#
#   in the python directory run ./fitsdkparser.py generate Profile.xlsx
#      
#

import re
import argparse
import json
import pprint
import openpyxl
import logging
import os
from inspect import currentframe,getframeinfo

MSG_COL_MESSAGE_NAME = 0
MSG_COL_FIELD_DEF = 1
MSG_COL_FIELD_NAME = 2
MSG_COL_FIELD_TYPE = 3
MSG_COL_ARRAY = 4
MSG_COL_COMPONENTS = 5
MSG_COL_SCALE = 6
MSG_COL_OFFSET = 7
MSG_COL_UNITS = 8
MSG_COL_BITS = 9
MSG_COL_ACCUMULATE = 10
MSG_COL_REF_FIELD_NAME = 11
MSG_COL_REF_FIELD_VALUE = 12
MSG_COL_COMMENT = 13
MSG_COL_PRODUCTS = 14
MSG_COL_EXAMPLE = 15

TYP_COL_TYPE_NAME = 0
TYP_COL_BASE_TYPE = 1
TYP_COL_VALUE_NAME = 2
TYP_COL_VALUE = 3
TYP_COL_COMMENT = 4

# internal
FIT_FLAG_NONE = 0b0000
FIT_FLAG_DATE = 0b0001
FIT_FLAG_REL =  0b0010
FIT_FLAG_PENDING = 0b0100


def fix_variable_name( var_name ):
    '''
    fix for reserved names
    '''
    if var_name == 'switch':
        return 'switch_'
    return var_name

base_type_alignments = {
    'uint16': 2,
    'enum': 1,
    'bool': 1,
    'sint8': 1,
    'uint8':1,
    'sint16':2,
    'uint16':2,
    'sint32':4,
    'uint32':4,
    'string':1,
    'uint8z':1,
    'uint16z':2,
    'uint32z':4,
    'byte':1,
    'sint64':8,
    'uint64':8,
    'uint64z':8,
    'float32':4
}


def first_line_with_annotate_comment(prefix = '', annotate = True):
    if not annotate:
        return []
    previous_frame = currentframe().f_back
    (filename, line_number,function_name, lines, index) = getframeinfo(previous_frame)
    return [ '{}//Generated by {}:{}:{}'.format(  prefix, function_name, os.path.basename(filename), line_number ) ]

def annotate_comment(comment, prefix = '', annotate = True):
    if not annotate:
        return []
    previous_frame = currentframe().f_back
    (filename, line_number,function_name, lines, index) = getframeinfo(previous_frame)
    return [ '{}//{} [{}:{}:{}]'.format(  prefix, comment, function_name, os.path.basename(filename), line_number ) ]

class Type :
    '''
    Represent a type and its values
       name: type name (ex: mesg_num)
       base_type: c type (ex: uint16)
       type_num: internal number for the type
       values: dict of name/value (ex: [{'name': 'record', 'value':20 },{'name':'session','value'::18 } ] )
       values_map: dict name: value (ex: {'record':20, 'session':18 } )
    '''
    
    def __init__(self,name, base_type, type_num,annotate=False):
        self.name = name
        self.base_type = base_type
        self.type_num = type_num
        self.values = []
        self.values_map = {}
        self.is_masked_value = False
        self.annotate = annotate

    def fit_type(self):
        return 'FIT_{}'.format( self.name.upper() )


    def is_string(self):
        return not self.is_masked_value

    def is_value(self):
        return self.is_masked_value
    
    def add_row(self,row):
        if len(row)>4 and row[TYP_COL_TYPE_NAME] is None and row[TYP_COL_BASE_TYPE] is None:
            if row[TYP_COL_VALUE_NAME] == 'mask':
                self.is_masked_value = True
            self.values.append( { 'name': row[TYP_COL_VALUE_NAME], 'value':row[TYP_COL_VALUE] } )
            self.values_map[row[TYP_COL_VALUE_NAME]] = row[TYP_COL_VALUE]
            return True
        else:
            return False

    def __repr__(self):
        return 'Type({}<{}>={}{{{}}})'.format( self.name, self.base_type, self.type_num, len(self.values) )
    
    def description(self):
        rv = [ '{}'.format( self ) ]
        for d in self.values:
            rv.append( '   {}: {}'.format( d['value'],d['name'] ) )
        return '\n'.join(rv)

    def value_for_string(self,val):
        return self.values_map[val]

    #--- swift type
    def swift_stmt_extension(self,use_type):
        rv = first_line_with_annotate_comment('', annotate = self.annotate)
        rv.extend( [ 'public extension {} {{'.format( use_type ),
               '  func name() -> String {',
               '    return {}(self)'.format(self.swift_fname_to_string()),
               '  }',
               '  static let invalid : FitMessageType = 0xFFFF'
              ] )
        for d in self.values:
            rv.append( '  static let {} : {} = {}'.format( d['name'], use_type, d['value'] ) )
        rv.append( '}' )
        return rv

    def swift_fname_to_string(self):
        return f'rzfit_swift_string_from_{self.name}'
    
    def swift_func_to_string(self,fileprivate=True):
        rv = first_line_with_annotate_comment('',annotate = self.annotate)
        if self.is_masked_value:
            mask = None
            for v in self.values:
                if v['name'] == 'mask':
                    mask = v['value']

            rv.extend( [ '{}func {}(_ input : {}) -> String'.format( 'fileprivate ' if fileprivate else 'public ', self.swift_fname_to_string(), self.objc_type() ),
                             '{',
                             '  let flag = input & (~{})'.format( mask ),
                            ] )
            for d in self.values:
                if d['name'] != 'mask':
                    rv.append( '  if flag == {} {{ return "{}" }}'.format( d['value'], d['name'] ) )
            rv.append( '  else {{ return "{}_\(flag)" }}'.format( self.name) )
            rv.extend( [ '  }',
                         ''] )
        else:
            rv.extend( [ '{}func {}(_ input : {}) -> String'.format( 'fileprivate ' if fileprivate else 'public ', self.swift_fname_to_string(), self.objc_type() ),
               '{',
               '   switch input {{'.format( self.name ),
              ] )
            for d in self.values:
                rv.append( '    case {}: return "{}"'.format( d['value'], d['name'] ) )
            rv.append( '    default: return "{}_\(input)"'.format( self.name) )
            rv.extend( [ '  }',
                         '}',
                        ''] )
        return rv
    
    def swift_fname_to_value(self):
        return f'rzfit_swift_value_from_{self.name}'

    def swift_func_to_value(self,fileprivate=True):
        if not self.is_masked_value:
            return []
        
        rv = first_line_with_annotate_comment(prefix = '', annotate=self.annotate)
        mask = None
        for v in self.values:
            if v['name'] == 'mask':
                mask = v['value']
        rv.extend( [ '{}func {}(_ input : {}) -> Double'.format('fileprivate ' if fileprivate else 'public', self.swift_fname_to_value(),self.objc_type() ),
                     '{',
                     '  let masked = input & {}'.format( mask ),
                     '  return Double( masked )',
                     '}',
                     ] )
        return rv

    def swift_fname_from_string(self):
        return f'rzfit_swift_string_to_{self.name}'
    
    def swift_func_from_string(self,fileprivate=True):
        rv = first_line_with_annotate_comment(prefix = '', annotate=self.annotate)
        rv.extend( [ '{}func {}(_ input : String) -> {}'.format( 'fileprivate ' if fileprivate else 'public ', self.swift_fname_from_string(), self.objc_type() ),
               '{',
               '   switch input {'
              ] )
        for d in self.values:
            rv.append( '    case "{}": return {};'.format( d['name'], d['value'] ) )
        rv.append( '   default: return {}_INVALID;'.format( self.objc_type() ) )
        rv.extend( [ '  }',
                     '}',
                     '' ] )
        return rv
    
    def swift_stmt_case_type_function_call(self):
        rv = first_line_with_annotate_comment(prefix = '', annotate=self.annotate)
        rv.extend( [
            '     case {}: return {}( {}(val) )'.format(self.type_num,  self.swift_fname_to_string(),self.objc_type() )
            ] )
        return rv

    def swift_fname_reverse_value(self):
        return 'rzfit_swift_reverse_value_{}'.format( self.name )

    def swift_func_reverse_value(self):
        rv = first_line_with_annotate_comment(prefix = '', annotate=self.annotate)
        rv.extend( [ 'fileprivate func {}(value : String) -> RzFitSwiftValue'.format(  self.swift_fname_reverse_value() ),
               '{',
               '   switch value {'
              ] )
        for d in self.values:
            rv.append( '    case "{}": return .string("{}")'.format( d['value'],d['name'] ) )
            rv.append( '    case "{}": return .string("{}")'.format( d['name'],d['value'] ) )
        rv.append( '   default: return .unknown'.format( self.objc_type() ) )
        rv.extend( [ '  }',
                     '}',
                     '' ] )
        return rv
        

        
    #--- objc type
    def objc_type(self):
        return 'FIT_{}'.format( self.base_type.upper() )

    def objc_typedef(self):
        rv = first_line_with_annotate_comment('',annotate = self.annotate)

        rv.extend( [ 'typedef {} {};'.format( self.objc_type(), self.fit_type() ) ] )
        elems = []
        sizes = (0,0)
        for d in self.values:
            one = ( '{}_{}'.format(self.fit_type(), d['name'].upper() ),
                         '(({}){})'.format(self.fit_type(), d['value'] ) )
            elems.append( one )
            sizes = ( max(sizes[0],len(one[0])), max( sizes[1],len(one[1]) ) )
        rv.append( '#define {0: <{width0}} {1: <{width1}}'.format( f'{self.fit_type()}_INVALID', f'{self.objc_type()}_INVALID', width0=sizes[0], width1=sizes[1] ) )
    
        for e in elems:
            rv.append( '#define {0: <{width0}} {1: <{width1}}'.format( e[0], e[1], width0=sizes[0], width1=sizes[1] ) )
        rv.append( '' )
        
        return rv
    
    def objc_fname_to_string(self):
        return 'rzfit_objc_string_from_{}'.format( self.name )

    def objc_func_to_string(self,fileprivate=True):
        var_name = fix_variable_name( self.name )
        rv = first_line_with_annotate_comment('',annotate = self.annotate)
        rv.extend( [ '{}NSString * {}( {} {} ){{'.format( 'static ' if fileprivate else '', self.objc_fname_to_string(), self.objc_type(), var_name ),
               '  switch({}){{'.format( var_name )
               ] )
        for d in self.values:
            rv.append( '    case {}: return @"{}";'.format( d['value'], d['name'] ) )
        rv.extend( [   '    default: return [NSString stringWithFormat:@"{}_%u", (unsigned int){}];'.format( self.name, var_name ),
                     '  }',
                     '}',
                     '',
                     ''
                     ] )
        return rv

    def objc_stmt_case_type_function_call(self):
        rv = first_line_with_annotate_comment('    ', annotate = self.annotate )
        rv.extend( [ 
               '     case {}: return {}( ({}) val);'.format( self.type_num, self.objc_fname_to_string(), self.objc_type() ),
               
               ] )
        return rv
    
class Field:
    '''
    field_num: field number (ex: 1)
    name: field name (ex: 'manufacturer' or 'product')
    type_name: type (ex: 'manufacturer' or 'uint16')
    fit_type: Type object if relevant or None
    scale: None or value
    offset: None or value
    unit: None or str (ex: 'bpm')
    member: member in a struct

    references: None or array of sub fields with reference_field/reference_field_value (ex [ Field(garmin_product) ]

    reference_field: None or array of field to check if should be used (ex: ['manufacturer','sport'] )
    reference_field_value: None or array of value to check if should be used (ex: ['garmin','running'] )
    '''
    def __init__(self,ctx,row):
        self.field_num = row[MSG_COL_FIELD_DEF]
        self.annotate = ctx.annotate
        self.name = row[MSG_COL_FIELD_NAME]
        self.type_name = row[MSG_COL_FIELD_TYPE]
        self.objc_type = 'FIT_{}'.format(self.type_name.upper() )
        self.scale = row[MSG_COL_SCALE]
        self.offset = row[MSG_COL_OFFSET]
        self.unit = row[MSG_COL_UNITS]
        self.unit_num = ctx.unit_num( self.unit )

        if self.type_name in ctx.types:
            self.base_type = ctx.types[self.type_name].base_type
        else:
            self.base_type = self.type_name

        self.objc_base_type = 'FIT_{}'.format(self.base_type.upper() )
        
        self.member = self.name 
        
        self.is_value = False
        self.is_date = False
        self.is_string = False
        self.is_fit_type = False
        self.is_array = False

        self.fit_type = None

        self.array_size = None
        self.include = False

        self.is_switched = False
        self.is_component = False
        self.switch_require_complete = False
        # some fields seem to be default, some other will require rest to be there
        # need to keep track so we default in switch to main field or wait for more information
        if not self.unit:
            self.switch_require_complete = True
        
        if self.type_name.endswith( 'date_time' ):
            self.is_date = True
        elif self.type_name in ctx.types:
            self.is_fit_type = True
            self.fit_type = ctx.types[self.type_name]
        elif self.type_name == 'string':
            self.is_string = True
        else:
            self.is_value = True

        if row[MSG_COL_ARRAY]:
            self.is_array = True
            if row[MSG_COL_ARRAY] != '[N]':
                # sometime the size is there
                digits = re.findall(r'\d+', row[MSG_COL_ARRAY])
                self.array_size = int( digits[0] )
                
        if row[MSG_COL_EXAMPLE]:
            self.include = True
            if (self.is_array or self.is_string) and not self.array_size:
                self.array_size = int( row[MSG_COL_EXAMPLE] )
            
        self.reference_field = row[MSG_COL_REF_FIELD_NAME]
        if row[MSG_COL_REF_FIELD_NAME]:
            self.reference_field = row[MSG_COL_REF_FIELD_NAME].replace( '\n','').split( ',' )
        else:
            self.reference_field = []
        if row[MSG_COL_REF_FIELD_VALUE]:
            self.reference_field_value = row[12].replace( '\n','').split( ',' )
        else:
            self.reference_field_value = []
            
        if len(self.reference_field_value) != len(self.reference_field):
            print( 'bug inconsistent reference_field {} {} {}'.format( self.name, row[11], row[12] ) )
        self.references = []

        self.components = None
        if row[MSG_COL_COMPONENTS]:
            
            components_name = row[MSG_COL_COMPONENTS].replace('\n','').split( ',')
            components_scale = str(row[MSG_COL_SCALE]).replace('\n','').split( ',') if row[MSG_COL_SCALE] else None
            components_bits = str(row[MSG_COL_BITS]).replace('\n','').split( ',') if row[MSG_COL_BITS] else None
            components_units = str(row[MSG_COL_UNITS]).replace('\n','').split( ',') if row[MSG_COL_UNITS] else None

            if len(components_name) > 1:
                self.is_component = True

                if components_units and len(components_units) == 1:
                    single = components_units[0]
                    components_units = [single for x in components_name]
                components = []
                for index,(name,bits) in enumerate(zip(components_name,components_bits)):
                    one = {'name':name,'bits':bits}
                    if components_scale and index < len(components_scale):
                        one['scale'] = components_scale[index]
                    if components_units and index < len(components_units):
                        one['unit'] = components_units[index]
                    components.append(one)
                self.components = components

        
    def add_reference(self,ctx,row):
        field = Field(ctx,row)
        if field.is_fit_type:
            if self.references and not self.is_fit_type:
                logging.debug( 'swifted field {} has value and enum, assuming value'.format( self ) )

            if not self.references:
                self.is_fit_type = True
                self.is_value = False
                
        self.is_switched = True
        self.references.append( field )

    def finalize(self,ctx,msg):
        pass

        
    def type_category(self):
        base = self.type_name
        if self.is_date:
            base = 'date'
        elif self.is_string:
            base = 'string'
        elif self.is_value:
            base =  'value'
        elif self.is_fit_type:
            if self.is_switched:
                base =  'multi'
            else:
                base =  '{}'.format( self.fit_type)
            
        if self.array_size:
            base = base + '[{}]'.format( self.array_size )

        return base

    def has_value(self):
        if self.is_value:
            return True
        if self.is_switched:
            for field in self.references:
                if field.has_value():
                    return True

        if self.components:
            return True

        if self.fit_type and self.fit_type.is_masked_value:
            return True
        
        return False
    
    def __repr__(self):
        if self.components:
            desc_components = ', components[{}]'.format( len(self.components) )
        else:
            desc_components = ''
            
        if self.is_switched:
            return  'Field({}={}<{}>, {}, switch{{{}}}{})'.format(self.name, self.field_num, self.base_type, self.type_category(), len(self.references), desc_components )
        else:
            if self.field_num:
                return  'Field({}={}<{}>, {}{})'.format(self.name, self.field_num, self.base_type, self.type_category(), desc_components )
            else:
                return  'Field({}<{}>, {}{})'.format(self.name, self.base_type, self.type_category(), desc_components )

    def base_type_alignment(self):
        if self.base_type in base_type_alignments:
            alignment = base_type_alignments[self.base_type]
        else:
            print( "MISSING ALIGNMENT {}".format( self.base_type ) )
            exit(0)

        if self.array_size and (self.is_array or self.is_string):
            total_size = self.array_size * alignment
            if total_size % 4 == 0:
                alignment = 4
            elif total_size % 2 == 0:
                alignment = 2
            else:
                total_size = 1

        return alignment
            
    def description(self):
        rv = [ repr(self) ]
        if self.references:
            for field in self.references:
                refs = ','.join(list(set(field.reference_field)))
                rv.append( 'switch({}): {}'.format( refs, field.description() ) )

        if self.components:
            for component in self.components:
                rv.append( 'compoment: {} = {}[{}]'.format( component['name'],self.name,component['bits'] ) )
        return '\n'.join( rv )
        
    def formula(self):
        if self.unit:
            return '({}x+{}) in [{}]'.format( self.multiplier, self.offset, self.unit )
        else:
            return ''
        
    def name_to_units(self):
        rv = {}
        if self.unit:
            rv = { self.name: self.unit}

        for references in self.references:
            sub = references.name_to_units()
            for (k,v) in sub.items():
                if k not in rv:
                    rv[k] = v
                else:
                    if rv[k] != v:
                        print( 'inconsistent for {}: {} {}'.format( self.name, v, rv[k] ) )
                        
        return rv

    #--- swift field
    def swift_unit_case_statement(self,prefix=''):
        if self.unit:
            return [ prefix + 'case "{}": return "{}"'.format( self.member,self.unit ) ]
        else:
            return None
    
    def swift_stmt_convert_value(self,ctx,message,prefix=''):
        lines = []
        member = self.member
        array_access = ''
        if self.is_array and self.array_size > 1:
            array_access = '.0'
        something_done = False
        if self.has_value():
            lines = first_line_with_annotate_comment(prefix,ctx.annotate)
            
            lines.extend( [ prefix + 'if x.{}{} != {}_INVALID  {{'.format( member, array_access, self.objc_base_type ) ] )
            if self.is_switched:
                switch_stmt = self.swift_stmt_case_convert_to_value(ctx, message)
                if switch_stmt:
                    lines.extend( switch_stmt )
                    something_done = True
            elif self.is_value:
                something_done = True
                if self.is_array:
                    lines.append( prefix + '  // Array[{}]'.format( self.array_size ) )

                formula = self.swift_expr_formula(ctx)
                lines.extend( [ prefix + '  let val : Double = {}'.format( formula ),
                                 prefix + '  rv[ "{}" ] = val'.format(self.name),
                                 ] )
            elif self.fit_type and self.fit_type.is_masked_value:
                something_done = True
                lines.append( prefix + '  rv[ "{}_value" ] = {}(x.{})'.format(self.name, self.fit_type.swift_fname_to_value(), member ) )
            
        
            lines.append( prefix + '}' )

        if not something_done:
            return []
        
        return lines

    def swift_stmt_convert_string(self,ctx,message,prefix='  '):
        lines = []
        
        if self.is_string or self.is_fit_type:
            if self.is_fit_type and not self.is_array:
                lines = first_line_with_annotate_comment(prefix,ctx.annotate)
                lines.extend( [ prefix + 'if( x.{} != {}_INVALID ) {{'.format( self.member, self.objc_base_type  ) ] )
                if self.is_switched:
                    lines.extend( self.swift_stmt_case_convert_to_string(ctx,message) )
                else:
                    type_obj = ctx.types[self.type_name]
                    lines.extend( [
                          prefix + '  rv[ "{}" ] = {}(x.{})'.format( self.member,type_obj.swift_fname_to_string(), self.member ),
                         ])

                lines.append( prefix + '}' )

            elif self.is_string:
                lines = first_line_with_annotate_comment(prefix,ctx.annotate)
                lines.extend( [ prefix + 'let {} = withUnsafeBytes(of: &x.{}) {{ (rawPtr) -> String in'.format(self.member,self.member),
                          prefix + '  let ptr = rawPtr.baseAddress!.assumingMemoryBound(to: CChar.self)',
                          prefix + '  return String(cString: ptr)',
                          prefix + '}',
                          prefix + 'if !{}.isEmpty {{'.format( self.member, self.member ),
                          prefix + '  rv[ "{}" ] = {}'.format( self.member, self.member ),
                          prefix + '}',
                          
                         ] )
            
        return lines
    
    def swift_stmt_convert_date(self,ctx,message,prefix=''):
        lines = []

        member = self.member

        if self.is_date:
            lines = first_line_with_annotate_comment(prefix,ctx.annotate)
            lines.extend( [ prefix + 'if x.{} != {}_INVALID  {{'.format( member, self.objc_base_type ),
                      prefix + '  let val : Date =  Date(timeIntervalSinceReferenceDate: Double(x.{})-347241600.0 )'.format( member ),
                      prefix + '  rv[ "{}" ] = val'.format(self.name),
                      prefix + '}'
                      ] )
            
        return lines

    def swift_stmt_components_convert_to_value(self,ctx,message,components):
        prefix = '         '
        rv = first_line_with_annotate_comment(prefix,ctx.annotate)

        components_tuples = []
        has_scale = False
        for component in components:
            component_tuple = '({}, "{}"'.format( component['bits'],component['name'] )
            if 'scale' in component:
                has_scale = True
                component_tuple += ', {}'.format(component['scale'])
            component_tuple += ')'
            components_tuples.append(component_tuple)


            
        rv.extend( [ prefix + 'var sourceData : UInt32 = UInt32(x.data)',
                     prefix + 'for info in [ {} ] {{'.format(', '.join(components_tuples)),
                     prefix + '  let bits = info.0',
                     prefix + '  let name = info.1'
                    ] )
        if has_scale:
            rv.append( prefix + '  let scale = info.2' )
            formula = 'Double(val) / Double(scale)'
        else:
            formula = 'Double(val)'
        
        rv.extend( [
                     prefix + '  let mask : UInt32 = (1 << bits ) - 1',
                     prefix + '  let val = sourceData & mask',
                     prefix + '  sourceData = sourceData >> bits',
                     prefix + '  rv[name] = {}'.format(formula),
                     prefix + '}'
                    ] )

        return rv
    
    def swift_stmt_case_convert_to_value(self,ctx,message):
        rv = []
        
        prefix = '         '
        if self.references:
            rv = first_line_with_annotate_comment('  ',ctx.annotate)
            something_done = False
            if_statement = 'if'
            else_conditions = []
            for r in self.references:
                if not r.reference_field:
                    logging.error( 'bug missing field {}.{}'.format( self.name, r.name ))
                for (onefield, oneval) in zip( r.reference_field, r.reference_field_value ):
                    ref_type_obj = message.type_for_field(ctx,onefield)
                    formula = self.swift_expr_formula(ctx)
                    if r.is_value:
                        something_done = True
                        rv.append('      {} x.{} == {} {{ // {}'.format( if_statement, onefield, ref_type_obj.value_for_string(oneval), oneval ))
                        if r.components:
                            rv.extend( self.swift_stmt_components_convert_to_value(ctx, message, r.components) )
                        else:
                            rv.extend( [ prefix + 'let val : Double = {}'.format( formula ),
                                         prefix + 'rv[ "{}" ] = val'.format( r.name ),
                                        ] )
                        if_statement = '}else if'
                    else:
                        else_conditions.append( 'x.{} != {} /* {} */'.format( onefield,ref_type_obj.value_for_string(oneval), oneval) )
                        
            if if_statement != 'if':
                # unclear we should have an else here
                # it will create a field with the value of the field, but given it's switch
                if else_conditions:
                    rv.extend( annotate_comment('not covered by string switch'.format(r.name), prefix, ctx.annotate) )
                    rv.append(  '      }}else if {} &&'.format(else_conditions[0] ) )
                    rv.extend( ['               ' + x + ' &&' for x in else_conditions[1:-1]] )
                    rv.append( '               ' + else_conditions[-1] + ' {' )

                    formula = self.swift_expr_formula(ctx)
                    rv.extend( [ '        let val : Double = {}'.format( formula ),
                                 '        rv[ "{}" ] = val'.format( self.name ),
                                 '      }',
                                ] )
                else:
                    rv.append( '      }else{' )
                    formula = self.swift_expr_formula(ctx)
                    rv.extend( [ '        let val : Double = {}'.format( formula ),
                                 '        rv[ "{}" ] = val'.format( self.name ),
                                 '      }',
                                ] )
            
            if not something_done:
                return []
        return rv

    def swift_stmt_case_convert_to_string(self,ctx,message):
        rv = first_line_with_annotate_comment('  ',ctx.annotate)

        if self.references:
            if_statement = 'if'

            for r in self.references:
                if not r.reference_field:
                    logging.error( 'bug', self.name, r.name )
                if r.name in ctx.types:
                    r_type_obj = ctx.types[r.name]
                    for (onefield, oneval) in zip( r.reference_field, r.reference_field_value ):
                        ref_type_obj = message.type_for_field(ctx,onefield)
                        rv.extend( [ '      {} x.{} == {} {{ // {}'.format( if_statement, onefield, ref_type_obj.value_for_string(oneval), oneval ),
                                     '        rv[ "{}" ] = {}({}(truncatingIfNeeded: x.{}))'.format( r.name,r_type_obj.swift_fname_to_string(), r_type_obj.objc_type(), self.name ),
                                     ] )
                        if_statement = '}else if'
            if if_statement != 'if':
                rv.append( '    }' )

        return rv

    def swift_stmt_case_to_string(self,ctx,message):
        rv = first_line_with_annotate_comment('  ',ctx.annotate)
        if self.references:
            rv.extend( [ '    case {}:'.format( self.field_num )] )
            if_statement = 'if'

            for r in self.references:
                if not r.reference_field:
                    logging.error( 'bug', self.name, r.name )
                for (onefield, oneval) in zip( r.reference_field, r.reference_field_value ):
                    rv.extend( [ '      {} strings["{}"] == "{}" {{'.format( if_statement, onefield, oneval ) ,
                                 '        return "{}"'.format( r.name ) ] )
                    if_statement = '}else if'
            if if_statement == 'if':
                rv.append( '    }' )
            else:
                if self.switch_require_complete:
                    rv.extend( ['      }else{',
                                '        return "__INCOMPLETE__"'.format( self.name ),
                                '      }'
                                ])
                else:
                    rv.extend( ['      }else{',
                                '        return "{}"'.format( self.name ),
                                '      }'
                                ])
        else:
            rv.extend( ['    case {}: return "{}"'.format(self.field_num, self.name ) ] )
            
        return rv

    def swift_stmt_case_reverse_value(self,ctx,message):
        rv = first_line_with_annotate_comment('    ',ctx.annotate)

        rv.extend( [
                '    case "{}": // {}'.format( self.name, self.type_name),
        ])
        if self.type_name == 'date_time':
            rv.append( '      guard let dbl : Double = Double(value) else { return .unknown }' )
            rv.append( '      let dat : Date =  Date(timeIntervalSinceReferenceDate: dbl-347241600.0 )' )
            rv.append( '      return .date(dat)' )
        elif self.type_name in ctx.types:
            ttype = ctx.types[ self.type_name ]
            rv.append( '      return {}(value: value)'.format( ttype.swift_fname_reverse_value() ) )
        else:
            rv.append( '      guard let dbl : Double = Double(value) else { return .unknown }' )
            rv.append( '      return .value(dbl)' )
        if self.references:
            for r in self.references:
                rv.extend( r.swift_stmt_case_reverse_value(ctx,message) )
            
        return rv
    
    #---- objc field
    def objc_stmt_build_references_variables(self,ctx,message):
        all_var = dict()
        for r in self.references:
            if not r.reference_field:
                logging.error( 'bug', self.name, r.name )
            for one in r.reference_field:
                all_var[ one ] = message.fields_map[one].field_num
        rv = first_line_with_annotate_comment('      ',ctx.annotate)
        for one,field_num in all_var.items():
            rv.append( '      FIT_UINT32 {} = fit_interp_string_value(interp, {});'.format( one, field_num ) )

        return rv;

    def objc_stmt_case_to_string(self,ctx,message):
        if self.references:
            rv = [ '    case {}:'.format( self.field_num ),
                   '    {' ]
            if_statement = 'if'

            rv.extend( self.objc_stmt_build_references_variables(ctx,message) );
                       
            for r in self.references:
                if not r.reference_field:
                    logging.error( 'bug', self.name, r.name )
                for (onefield, oneval) in zip( r.reference_field, r.reference_field_value ):
                    rv.extend( [ '      {}( {} == {} ){{ // {} '.format( if_statement, onefield, message.type_for_field(ctx,onefield).value_for_string(oneval),oneval ),
                                 '         return @"{}";'.format( r.name ),
                                ] )
                    if_statement = '}else if'
            if if_statement == 'if':
                rv.append( '    }' )
            else:
                rv.extend( [ '      }else{',
                             '        return @"{}";'.format( self.name ),
                             '      }'
                            ])
            rv.append( '    }' )
            return rv
        else:
            return [ '    case {}: return @"{}";'.format( self.field_num, self.name ) ]
       
    def objc_expr_fit_field_info(self,ctx,pending=False):
        rv = None
        scale = 0
        offset = 0
        unit = 0
        fit_type = 0
        flags = FIT_FLAG_NONE
        report = False
        if self.scale and isinstance(self.scale, int ):
            scale = self.scale
            report = True
        if self.offset:
            offset = self.offset
            report = True
        if self.type_name and self.type_name in ctx.types:
            fit_type = ctx.types[ self.type_name ].type_num
            if self.type_name == 'date_time' or self.type_name == 'local_date_time':
                flags = FIT_FLAG_DATE
            report = True
        if self.unit and self.unit in ctx.units:
            unit = ctx.units[ self.unit ]
        report = True
        if pending:
            flags |= FIT_FLAG_PENDING
        if report:
            rv = '(FIT_FIELD_INFO){{.scale = {}, .offset = {}, .fit_type = {}, .fit_unit = {}, .fit_flag = {} }}'.format( scale,offset,fit_type,unit,flags )

        return rv

    def objc_stmt_case_to_field_info(self,ctx,message):
        rv = first_line_with_annotate_comment('    ',ctx.annotate)
        if self.references:
            rv.extend( [ '    case {}: // {}'.format( self.field_num, self.name ),
                         '    {',
                         ] )
            if_statement = 'if'
            rv.extend( self.objc_stmt_build_references_variables(ctx,message) )
                       
            for r in self.references:
                if not r.reference_field:
                    logging.error( 'bug', self.name, r.name )
                fit_field_info = r.objc_expr_fit_field_info(ctx)
                if fit_field_info:
                    for (onefield, oneval) in zip( r.reference_field, r.reference_field_value ):
                        rv.extend( [ '      {}( {} == {} ){{ // {} '.format( if_statement, onefield, message.type_for_field(ctx,onefield).value_for_string(oneval), oneval ),
                                     '         return {};'.format( fit_field_info ),
                                    ] )
                        if_statement = '}else if'
            if if_statement != 'if':
                rv.append(  '      }'  )

            if self.is_value:
                rv.append(  '      return {};'.format( self.objc_expr_fit_field_info(ctx) ) )
            else:
                rv.append(  '      return (FIT_FIELD_INFO){.scale = 0, .offset = 0, .fit_type = FIT_TYPE_PENDING, .fit_unit = 0, .fit_flag = 0 };' )

            rv.append( '    }' )
                    
        else:
            fit_field_info = self.objc_expr_fit_field_info(ctx)
            if fit_field_info:
                rv.append( '    case {}: return {}; // {}'.format( self.field_num, fit_field_info, self.name ) )
                
        return rv

    def swift_expr_formula(self,ctx):
        if self.is_array and self.array_size > 1:
            formula = 'Double(x.{}.0)'.format(self.name)
        else:
            formula = 'Double(x.{})'.format(self.name)
        # ignore scale that are multi field ex: compressed_speed_distance = 100,16
        if self.scale and ',' not in str(self.scale) and float(self.scale) != 1.0:
            formula = '({}/Double({}))'.format( formula, self.scale )
        if self.offset and float(self.offset) != 0.0:
            formula += '-Double({})'.format(self.offset)
        return formula
                            
class Message:
    '''
    A message name comes from the Messages tab of profile.xlsx
    It contains a name, which should be match in the type mesg_num
    and a list of fields definition for the message

    name: name of the message (ex: file_id, record, ..)
    mesg_num: the mesg num number from the type definition (ex: 18 (session), 20 (record)...
    struct_name: objc type for structure (ex: FIT_FILE_ID_MESG, FIT_RECORD_MESG)
    fields: array of fields in order of the Profile read [Field(file_id),...Field(record)...]
    fields_map: name to field {'file_id': Field(file_id), ...}
    '''
    def __init__(self,ctx,name):
        self.name = name
        self.mesg_num = ctx.types['mesg_num'].value_for_string( name )
        self.fields = []
        self.fields_map = {}
        
        self.struct_name = 'FIT_{}_MESG'.format( self.name.upper() )

    def __repr__(self):
        return( 'Message({}={})[{}]'.format( self.name, self.mesg_num, len( self.fields ) ) )
        
    def add(self,ctx,row):
        if row[MSG_COL_FIELD_DEF] is not None:
            field = Field(ctx,row)

            self.fields.append( field )
            self.fields_map[ field.name ] = field
        elif len(self.fields)>0:
            self.fields[-1].add_reference(ctx,row)

    def finalize(self,ctx):
        for field in self.fields:
            field.finalize(ctx,self)
            
    def type_for_field(self,ctx,field_name):
        # field ex: manufacturer
        #    return type for that field
        field = self.fields_map[field_name]
        return ctx.types[ field.type_name ]
    
    def has_switched_field(self):
        rv = False
        for f in self.fields:
            if f.is_switched:
                rv = True
        return rv

    def has_included(self):
        rv = False
        for f in self.fields:
            if f.include:
                rv = True
        return rv
    
    def field_to_unit(self,all_fields):
        for f in self.fields:
            for (k,v) in f.name_to_units().items():
                if k not in all_fields:
                    all_fields[k] = {}
                all_fields[k][self.name] = v

    def fields_sorted_by_alignments(self):
        rv = sorted( self.fields, key=lambda x: x.base_type_alignment(), reverse=True )
        return rv
                
    def objc_type_mesg_def_struct(self):
        return 'FIT_{}_MESG_DEF'.format( self.name.upper() )

    def objc_var_mesg_def(self):
        return '{}_mesg_def'.format( self.name )
        
    def mesg_def_struct_type_name(self):
        return 'FIT_{}_MESG_DEF'.format( self.name.upper() )
                
    #--- Swift message
    def swift_fname_field_num_to_string(self):
        return 'rzfit_swift_field_num_to_string_for_{}'.format( self.name )

    def swift_func_field_num_to_string(self,ctx):
        rv = first_line_with_annotate_comment('  ',ctx.annotate)

        if self.has_switched_field():
            rv.append( 'fileprivate func {}( field_num : FIT_UINT16 , strings : [String:String] ) -> String {{'.format( self.swift_fname_field_num_to_string() ) )
        else:
            rv.append( 'fileprivate func {}( field_num : FIT_UINT16 ) -> String {{'.format( self.swift_fname_field_num_to_string() ) )
        rv.append( '  switch field_num {' )
        for field in self.fields:
            rv.extend( field.swift_stmt_case_to_string(ctx,self ) )
        rv.extend( [ '    default: return "{}_field_num_\(field_num)"'.format( self.name ),
                     '  }',
                     '}'
                     ])
        return rv

    def swift_fname_value_dict(self):
        return 'rzfit_swift_value_dict_for_{}'.format( self.name )
    
    def swift_func_value_dict(self,ctx):
        rv = first_line_with_annotate_comment('',ctx.annotate)
        rv.extend( [ 'fileprivate func {}( ptr : UnsafePointer<{}>) -> [String:Double] {{'.format( self.swift_fname_value_dict(), self.struct_name ) ] )
        elems = []
        
        for field in self.fields_sorted_by_alignments():
            if field.include:
                elems += field.swift_stmt_convert_value(ctx, self, '  ')

        if elems:
            rv += [ '  var rv : [String:Double] = [:]',
                    '  let x : {} = ptr.pointee'.format(self.struct_name)
                    ]
            rv += elems
            rv += [ '  return rv',
                    '}' ]
        else:
            rv += [ '  return [:]',
                    '}' ]
        return rv
    
    def swift_fname_string_dict(self):
        return 'rzfit_swift_string_dict_for_{}'.format( self.name )
    
    def swift_func_string_dict(self,ctx):
        rv = first_line_with_annotate_comment('',ctx.annotate)

        rv.extend( [ 'fileprivate func {}( ptr : UnsafePointer<{}>) -> [String:String] {{'.format(self.swift_fname_string_dict(), self.struct_name ) ] )
        elems = []
        hasString = False
        for field in self.fields_sorted_by_alignments():
            if field.include:
                if field.is_string:
                    hasString = True
                elems += field.swift_stmt_convert_string(ctx,self)
        if elems:
            rv += [ '  var rv : [String:String] = [:]',
                    '  {} x : {} = ptr.pointee'.format('var' if hasString else 'let', self.struct_name)
               ]
            rv += elems
            rv += [ '  return rv',
                    '}' ]
        else:
            rv += [ '  return [:]',
                    '}'
                    ]

        return( rv )
    
    def swift_fname_date_dict(self):
        return 'rzfit_swift_date_dict_for_{}'.format( self.name )
    
    def swift_func_date_dict(self,ctx):
        rv = first_line_with_annotate_comment('',ctx.annotate)

        rv.extend( [ 'fileprivate func {}( ptr : UnsafePointer<{}>) -> [String:Date] {{'.format( self.swift_fname_date_dict(), self.struct_name ),
               ] )
        elems = []
        
        for field in self.fields:
            if field.include:
                elems += field.swift_stmt_convert_date(ctx, self, '  ')

        if elems:
            rv += [ '  var rv : [String:Date] = [:]',
                    '  let x : {} = ptr.pointee'.format(self.struct_name)
                    ]
            rv += elems
            rv += [ '  return rv',
                    '}' ]
        else:
            rv += [ '  return [:]',
                    '}' ]
        return rv
    

    def swift_stmt_case_fit_mesg(self,ctx):
        rv = first_line_with_annotate_comment('  ',ctx.annotate)
        rv.extend( [ '    case {}: // {}'.format( self.mesg_num, self.name ),
               '      uptr.withMemoryRebound(to: {}.self, capacity: 1) {{'.format( self.struct_name ),
               '      rv = FitMessage( mesg_num:    {},'.format( self.mesg_num ),
               '                       mesg_values: {}(ptr: $0),'.format(  self.swift_fname_value_dict()),
               '                       mesg_enums:  {}(ptr: $0),'.format(  self.swift_fname_string_dict()),
               '                       mesg_dates:  {}(ptr: $0))'.format(  self.swift_fname_date_dict()),
               '      }'
              ] )
        return rv

    def swift_fname_reverse_value(self):
        return 'rzfit_swift_reverse_value_{}'.format( self.name )
    
    def swift_func_reverse_value(self,ctx):
        rv = first_line_with_annotate_comment('', ctx.annotate)
        rv.extend( [
            'fileprivate func {}(field: String, value: String) -> RzFitSwiftValue {{'.format( self.swift_fname_reverse_value() ),
            '  switch field {'
        ])
        for field in self.fields:
            rv.extend( field.swift_stmt_case_reverse_value(ctx,self) )
                
        rv.extend( [
            '  default:',
            '    return .unknown',
            '  }',
            '}'
        ])
        return rv
    
    #--- objc message
    def objc_fname_field_num_to_string(self):
        return 'rzfit_objc_field_num_to_string_for_{}'.format( self.name )
            
    def objc_func_field_num_to_string(self,ctx):
        rv = first_line_with_annotate_comment('',ctx.annotate)

        if self.has_switched_field():
            rv.append( 'static NSString * {}( FIT_UINT8 field_num, FIT_INTERP_FIELD * interp ){{'.format( self.objc_fname_field_num_to_string() ) ),
        else:
            rv.append( 'static NSString * {}( FIT_UINT8 field_num ){{'.format( self.objc_fname_field_num_to_string() ) )
        rv.append( '  switch( field_num ){'  )
        for field in self.fields:
            rv.extend( field.objc_stmt_case_to_string(ctx,self) )
        rv.extend( [ '    default: return [NSString stringWithFormat:@"{}_field_num_%u", (unsigned int)field_num];'.format( self.name) ,
                     '  }',
                     '}',
                     '',
                     ] )
        return rv

    def objc_fname_field_info(self):
        return 'rzfit_objc_field_info_for_{}'.format( self.name )

    def objc_func_field_info(self, ctx ):
        needed = []
        for f in self.fields:
            one = f.objc_stmt_case_to_field_info(ctx,self)
            if one:
                needed.extend( one )
        rv = first_line_with_annotate_comment('',ctx.annotate)
        if needed:
            if self.has_switched_field():
                rv.append( 'static FIT_FIELD_INFO {}(FIT_UINT16 field, FIT_INTERP_FIELD * interp){{'.format( self.objc_fname_field_info() ) )
            else:
                rv.append( 'static FIT_FIELD_INFO {}(FIT_UINT16 field){{'.format( self.objc_fname_field_info() ) )
                
            rv.append( '  switch( field ){' ),
            rv.extend( needed )
            rv.extend( [  '    default: return (FIT_FIELD_INFO){.scale = 0, .offset = 0, .fit_type = 0, .fit_unit = 0, .fit_flag = 0 };',
                          '  }',
                          '}',
                          ] )
        return rv

    def objc_mesg_struct(self,ctx):
        rv = []
        
        fields = []
        for f in self.fields_sorted_by_alignments():
            if f.include:
                fields.append( f )

        if not fields:
            return rv

        rv = first_line_with_annotate_comment('',ctx.annotate)
        rv.extend( [ 'typedef struct {' ] )

        for f in fields:
            if f.array_size:
                rv.append(  '  {} {}[{}]; // {}'.format( f.objc_base_type, f.name, f.array_size, f.fit_type.name if f.fit_type else '' )  )
            else:
                rv.append(  '  {} {}; // {}'.format( f.objc_base_type, f.name, f.fit_type.name if f.fit_type else '' )  )

        rv.extend( ['}} {};'.format( self.struct_name ), '' ] )

        return rv
    
    def objc_mesg_def(self,ctx):
        rv = []
        
        fields = []
        for f in self.fields_sorted_by_alignments():
            if f.include:
                fields.append( f )

        if not fields:
            return rv

        rv = first_line_with_annotate_comment('',ctx.annotate)
        rv.extend( [ 'typedef struct {',
                     '  FIT_UINT8 reserved_1;',
                     '  FIT_UINT8 arch;',
                     '  FIT_UINT16 global_mesg_num;',
                     '  FIT_UINT8 num_fields;',
                     '  FIT_UINT8 fields[FIT_FIELD_DEF_SIZE * {:2}];'.format( len( fields ) ),
                     '}} {};'.format( self.objc_type_mesg_def_struct() ),
                     ''
                     ] )

        rv.extend( [ 'static const {} {} = {{'.format(self.objc_type_mesg_def_struct(), self.objc_var_mesg_def()),
               '  0, // reserved_1',
               '  FIT_ARCH_ENDIAN, // arch,',
               '  /* {} */{}, // mesg_num,'.format( self.name, self.mesg_num ),
               '  {},'.format( len(fields) ),
               '  {'
            ] )

        sizes = (0, 0, 0)
        entries = []
        for f in fields:
            base_type = 'FIT_BASE_TYPE_{}'.format( f.base_type.upper() )
            if base_type == 'FIT_BASE_TYPE_BOOL':
                base_type = 'FIT_BASE_TYPE_ENUM'
            one = [ '/* {} */{},'.format( f.name, f.field_num ),
                    '(sizeof({})*{}),'.format( f.objc_base_type, f.array_size if f.array_size else 1 ),
                    '{},'.format( base_type )
            ]
            entries.append( one )
            sizes = ( max(len(one[0]), sizes[0]), max(len(one[1]), sizes[1]), max(len(one[2]), sizes[1]) )
            
        for one in entries:
            rv.append( '    ' + '{0: <{width0}} {1: <{width1}} {2: <{width2}}'.format( one[0], one[1], one[2], width0 = sizes[0], width1 = sizes[1], width2 = sizes[2] ) )

        rv.extend( [ '  }',
                     '};'
                     ] )
        return rv
        
class Profile:
    '''
    units: dict name to internal unit name (ex: { 'bpm': 1 } )
    types: dict name to Type object (ex: { 'garmin_product': Type(garmin_product) } )
    messages: dict name to Message object (ex: { 'mesg_num' : Message(mesg_num) } )
    structs: dict of fit type to Struct defined in c (ex: { 'FIT_RECORD_MESG' : Struct(record) } ) 
    '''
    def __init__(self,path_to_profile, types=None, messages=None, fields=None, verbose=True, annotate=False):
        '''
        path_to_profile: path to Profile.xlsx from the Fit SDK
        types: array of type names to focus on for generation function or None for all (ex: ['sport','mesg_num'...])
        messages: array of messages to focus on or None for all (ex: ['record','session',...])
        verbose: flag to suppress output of progresses
        '''
        self.profile = path_to_profile
        self.verbose = verbose
        self.annotate = annotate
        self.focus_types = types
        self.focus_messages = messages
        self.focus_fields = fields
        self.parse_profile_excel()

    def parse_profile_excel(self):
        logging.info( 'Parsing {}'.format( self.profile ) )
            
        wb = openpyxl.load_workbook(filename=self.profile)
        ws_types = list(wb['Types'].values)
        self.types = {}
        current = None

        self.types_columns = list(ws_types[0])
        # check consistency with our variables
        for idx,col in enumerate(list(self.types_columns)):
            varname = 'TYP_COL_{}'.format(col.upper().replace(' ', '_').replace('#','').replace(':',''))
            if eval(varname) != idx:
                logging.error( '{} = {} but in spreadsheet is col {}'.format(varname, eval(varname), idx))

        for row in ws_types[1:]:
            if len(row)>0 and row[TYP_COL_TYPE_NAME] and row[TYP_COL_BASE_TYPE]:
                # len+1 so 0 means no type
                current = Type( row[TYP_COL_TYPE_NAME], row[TYP_COL_BASE_TYPE], len(self.types)+1, annotate=self.annotate )
                self.types[ current.name ] = current
            elif current:
                # special case with duplicated number, breaks switch
                if row[TYP_COL_COMMENT] and row[TYP_COL_COMMENT].startswith('Deprecated' ) and row[TYP_COL_VALUE_NAME] == 'forecast':
                    continue
                current.add_row( row )

        logging.info( 'Read {} types'.format( len(self.types ) ) )

        ws_messages = list(wb['Messages'].values)
        self.messages_columns = [x.strip() for x in list(ws_messages[0]) if x]

        for idx,col in enumerate(list(self.messages_columns)):
            varname = 'MSG_COL_{}'.format(col.upper().replace(' #','').replace(' ', '_').replace(':',''))
            if eval(varname) != idx:
                logging.error( '{} = {} but in spreadsheet is col {}'.format(varname, eval(varname), idx))
        
        self.messages = {}
        current = None
        self.units = {}
        
        for row in ws_messages[1:]:
            if row[MSG_COL_MESSAGE_NAME]:
                if current:
                    current.finalize(self)
                
                current = Message(self,row[MSG_COL_MESSAGE_NAME])
                self.messages[ current.name ] = current
            elif current and row[MSG_COL_FIELD_NAME]:
                current.add( self,row )
                
        if self.verbose:
            logging.info( 'Read {} messages'.format( len(self.messages ) ) )
            logging.info( 'Read {} units'.format( len(self.units ) ) )
        
    def arg_types(self):
        rv = []
        if self.focus_types:
            for i in self.focus_types:
                if i in self.types:
                    rv.append( self.types[i] )
                elif int(i) > 0:
                    for t in self.types.values():
                        if int(i) == int(t.type_num):
                            rv.append( t )
        else:
            rv = [self.types[x] for x in self.ordered_types()]
                            
        return rv
    
    def arg_messages(self):
        rv = []
        if self.focus_messages:
            for i in self.focus_messages:
                if i in self.messages:
                    rv.append( self.messages[i] )
                elif int(i) > 0:
                    for m in self.messages.values():
                        if int(m.mesg_num) == int(i):
                            rv.append( m )
            # this message is required to be always here to compiled, as needed for developer field decoding code
            if 'field_description' not in self.focus_messages:
                rv.append( self.messages['field_description'] )
        else:
            rv = self.messages.values()
        return rv

    def debug_field(self,message,field):
        if self.debug and self.focus_field:
            return field in self.arg_fields(message)
        return False

    def debug_message(self,message):
        if self.debug and self.focus_messages:
            return message in self.arg_messages()
        return False
    
    def arg_fields(self,message):
        rv = []
        if self.focus_fields:
            for i in self.focus_fields:
                if i in message.fields_map:
                    rv.append( message.fields_map[i] )
                else:
                    try:
                        if int(i) > 0:
                            for f in message.fields:
                                if int(f.field_num) == int(i):
                                    rv.append( f )
                    except:
                        # if not an int, just ignore
                        pass
        else:
            rv = message.fields
        return rv
                
    def unit_num( self, unit_name ):
        if not unit_name:
            return 0
        
        if unit_name not in self.units:
            self.units[ unit_name ] = len( self.units ) + 1
        return self.units[ unit_name ]
    
    def ordered_types(self):
        ordered = sorted( self.types.keys(), key=lambda x: self.types[x].type_num )
        return ordered
        
    #---- objc context
    def objc_fname_field_info(self):
        return 'rzfit_objc_field_info'
    
    def objc_func_field_info(self):
        rv = first_line_with_annotate_comment('',self.annotate)
        rv.extend( [ 'FIT_FIELD_INFO {}( FIT_UINT16 global_mesg_num, FIT_UINT16 field, FIT_INTERP_FIELD * interp ){{'.format( self.objc_fname_field_info() ),
                     '  switch(global_mesg_num){',
                    ] )
        for message in self.messages.values():
            mesg_num = message.mesg_num
            mesg_name = message.name
            if message.has_switched_field():
                rv.append( '    case {}: return {}(field,interp);'.format( mesg_num, message.objc_fname_field_info() ) )
            else:
                rv.append( '    case {}: return {}(field);'.format( mesg_num, message.objc_fname_field_info() ) )
        rv.extend( [ '    default: return (FIT_FIELD_INFO){.scale = 0, .offset = 0, .fit_type = 0, .fit_unit = 0, .fit_flag = 0 };',
                     '  }',
                     '}'
                     ] )
        return rv
            

    def objc_fname_unit_to_string(self):
        return 'rzfit_objc_unit_to_string'
    
    def objc_func_unit_to_string(self):
        rv = first_line_with_annotate_comment('',self.annotate)
        rv.extend( [ 'NSString * {}( FIT_UNIT fit_unit ){{'.format( self.objc_fname_unit_to_string() ),
               '  switch( fit_unit ){'
               ] )
        ordered = sorted( self.units.keys(), key=lambda x: self.units[x] )
        for k in ordered:
            rv.append( '    case {}: return @"{}";'.format( self.units[k], k.replace( '\n','' ) ) )
        rv.extend( [ '    default: return [NSString stringWithFormat:@"FIT_UNIT_%u", (unsigned int)fit_unit];' ,
                     '  }',
                     '}',
                     ''
                     ] )
        return rv

    def objc_fname_type_to_string(self):
        return 'rzfit_objc_type_to_string'
    
    def objc_func_type_to_string(self):
        rv = first_line_with_annotate_comment('',self.annotate)
        rv.extend( [ 'NSString * {}( FIT_TYPE fit_type, FIT_UINT32 val ){{'.format( self.objc_fname_type_to_string() ),
               '  switch( fit_type ){'
               ] )
        ordered = self.ordered_types()
        for k in ordered:
            rv.extend( self.types[k].objc_stmt_case_type_function_call() )
        rv.extend( [ '    default: return [NSString stringWithFormat:@"FIT_TYPE_%u_VALUE_%u", (unsigned int)fit_type, (unsigned int)val];' ,
                     '  }',
                     '}',
                     ''
                     ] )
        return rv

    def objc_fname_field_num_to_string(self):
        return 'rzfit_objc_field_num_to_string'
    
    def objc_func_field_num_to_string(self):
        mesg_num = self.types['mesg_num']
        rv = first_line_with_annotate_comment('',self.annotate)

        rv.extend( [ 'NSString * {}( FIT_UINT16 global_mesg_num, FIT_UINT16 field, FIT_INTERP_FIELD * interp ){{'.format( self.objc_fname_field_num_to_string() ),
               '  switch( global_mesg_num ){'
               ] )
        for t in mesg_num.values:
            mesg_name = t['name']
            if mesg_name not in self.messages:
                if self.verbose:
                    logging.debug( 'Message {} in mesg_num type has no definition, skipping for objc'.format( mesg_name ) )
            else:
                mesg = self.messages[ mesg_name ]
                if mesg.has_switched_field():
                    rv.append( '   case {}: return {}(field,interp);'.format( t['value'], mesg.objc_fname_field_num_to_string() ) )
                else:
                    rv.append( '   case {}: return {}(field);'.format( t['value'], mesg.objc_fname_field_num_to_string() ) )
        rv.extend( [ '    default: return [NSString stringWithFormat:@"MESG_NUM_%u_FIELD_%u", (unsigned int)global_mesg_num, (unsigned int)field];' ,
                     '  }',
                     '}',
                     ''
                     ] )
        return rv

    def objc_var_fit_mesg_defs(self):
        return 'reference_mesg_defs'

    def objc_fit_mesg_defs_forward_declare(self):
        rv = []
        messages = []
        for m in self.arg_messages():
            if m.has_included():
                messages.append( m )
                
        rv.extend( [ 'extern void fit_set_{}();'.format( self.objc_var_fit_mesg_defs(), len(messages) ),
                     ''
                    ] )
                       
        return rv
    
    def objc_fit_mesg_defs(self):
        rv = first_line_with_annotate_comment('',self.annotate)
        messages = []
        for m in self.arg_messages():
            if m.has_included():
                messages.append( m )

        if messages:
            rv.extend( [ 'FIT_UINT8 {}_size = {};'.format( self.objc_var_fit_mesg_defs(), len( messages ) ),
                         'FIT_CONST_MESG_DEF_PTR {}[] = {{'.format( self.objc_var_fit_mesg_defs() )
                        ] )
            for m in messages:
                rv.append( '  (FIT_CONST_MESG_DEF_PTR) &{},'.format( m.objc_var_mesg_def() ) )
            rv.extend( [ '};', '' ] )

        rv.extend( ['void fit_set_{}() {{'.format( self.objc_var_fit_mesg_defs(), len(messages) ),
                    '  Fit_SetMesgDefs({}, {}_size);'.format( self.objc_var_fit_mesg_defs(), self.objc_var_fit_mesg_defs() ),
                    '}',
                    ] )
        return rv
        
    #--- swift Profile
    def swift_unit_functions(self):
        rv = first_line_with_annotate_comment('  ',self.annotate)
        rv = [ 'func rzfit_swift_known_units( ) -> [String] {' ,
               '  return  ['
               ]
        for k in self.units.keys():
            rv.append( '  "{}",'.format( k.replace( '\n', '' ) ) )
        rv.extend( [ '  ]' ,
                     '}',
                     ''
                     ] )

        rv.extend( [ 'func rzfit_swift_unit_for_field( mesg_num : FIT_UINT16, field : String ) -> String? {',
                     '  switch field {'
                     ] )

        field_to_unit = {}
        mesg_num = self.types['mesg_num']
        for (name,message) in self.messages.items():
            message.field_to_unit(field_to_unit)

        for (f,defs) in field_to_unit.items():
            units = set(defs.values())
            if len( units ) == 1:
                rv.append( '   case "{}": return "{}"'.format( f, next(iter(units))).replace( '\n','' ) )
            else:
                rv.extend( [ '    case "{}": '.format( f ),
                             '        switch mesg_num {',
                            ] )
                for (m,u) in defs.items():
                    rv.append( '      case {}: return "{}" // {}'.format( mesg_num.values_map[m], u, m ) )
                rv.extend( [ '      default: return nil',
                             '     }'
                             ] )
            
        rv.extend( [ '    default: return nil',
                     '   }',
                     '}' ] )
        return rv


    def swift_fname_type_to_string(self):
        return 'rzfit_swift_string_for_type'

    def swift_func_type_to_string(self):
        rv = [ 'func {}(fit_type : FIT_UINT8, val : FIT_UINT32 ) -> String {{'.format( self.swift_fname_type_to_string() ),
               '  switch fit_type {'
               ]
        ordered = self.ordered_types()
        for k in ordered:
            rv.extend( self.types[k].swift_stmt_case_type_function_call() )
        rv.extend( [ '    default: return "fit_type_\(fit_type)_\(val)"',
                     '  }',
                     '}' ] )
                     
        return rv


    def swift_fname_reverse_value(self):
        return 'rzfit_swift_reverse_value'
        
    def swift_func_reverse_value(self):
        rv = first_line_with_annotate_comment('', self.annotate)
        rv.extend( [
            'public enum RzFitSwiftValue {',
            '  case string(String)',
            '  case value(Double)',
            '  case date(Date)',
            '  case unknown',
            '}',
            '',
            'public func {}(mesg: String, field: String, value: String) -> RzFitSwiftValue {{'.format( self.swift_fname_reverse_value() ),
            '  switch mesg {'
        ])
        for mesg in self.types['mesg_num'].values:
            if mesg['name'] in self.messages:
                message = self.messages[ mesg['name'] ]
                rv.extend( [ '  case "{}": // {}'.format( mesg['name'], mesg['value'] ),
                             '    return {}(field: field, value: value )'.format(message.swift_fname_reverse_value()),
                             ] )
                           
        rv.extend( [
            '  default:',
            '    return .unknown',
            '  }',
            '}'
        ])

        return rv
                   
    def swift_fname_field_num_to_string(self):
        return 'rzfit_swift_field_num_to_string'

    def swift_func_field_num_to_string(self):
        rv = first_line_with_annotate_comment('',self.annotate)

        mesg_num = self.types['mesg_num']
        rv.extend( [ 'func {}( mesg_num : FIT_UINT16, field_num : FIT_UINT16, strings : [String:String]) -> String {{'.format( self.swift_fname_field_num_to_string() ),
               '  switch mesg_num {'
              ] )
        for t in mesg_num.values:
            mesg_name = t['name']
            if mesg_name not in self.messages:
                logging.debug( 'Message {} in mesg_num type not defined, skipping for swift'.format( mesg_name ) )
            else:
                mesg = self.messages[mesg_name]
                if mesg.has_switched_field():
                    rv.append( '    case {}: return {}(field_num: field_num, strings: strings)'.format( t['value'], mesg.swift_fname_field_num_to_string() ) )
                else:
                    rv.append( '    case {}: return {}(field_num: field_num)'.format( t['value'], mesg.swift_fname_field_num_to_string() ) )
        rv.extend( [ '    default: return "mesg_num_\(mesg_num)_field_num_\(field_num)"',
                     '   }',
                     '}' ] )
        return rv
    
    def swift_func_messages_dict(self):
        rv = first_line_with_annotate_comment('  ',self.annotate)
        messages = self.arg_messages()
        for s in messages:
            if s.has_included():
                rv.extend( s.swift_func_value_dict(self) )
                rv.extend( s.swift_func_string_dict(self) )
                rv.extend( s.swift_func_date_dict(self) )

        return rv

    def swift_fname_build_mesg(self):
        return 'rzfit_swift_build_mesg'

    def swift_func_build_mesg(self):
        rv = first_line_with_annotate_comment('  ',self.annotate)

        rv.extend( [
            'func {}(mesg_num : FIT_MESG_NUM, uptr : UnsafePointer<UInt8>) -> FitMessage? {{'.format(self.swift_fname_build_mesg()),
            '    var rv : FitMessage? = nil',
            '    switch mesg_num {',
            ])

        ordered = sorted(self.arg_messages(), key=lambda x: x.mesg_num)
        for message in ordered:
            if message.has_included():
                rv.extend( message.swift_stmt_case_fit_mesg(self) )

        rv.extend( [
            '    default:',
            '       rv = FitMessage( mesg_num: mesg_num, mesg_values: [:], mesg_enums: [:], mesg_dates: [:])',
            '    }',
            '    return rv',
            '}'
            ] )

        return rv
            
class Command :
    def __init__(self,args):
        self.args = args
        if self.args.quiet:
            logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.WARNING )
        else:
            logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)
            
        messages = args.message.split( '+' ) if args.message else None
        types = args.type.split( '+') if args.type else None
        fields = args.field.split( '+' ) if args.field else None
        
        self.context = Profile(args.profile,messages=messages,fields=fields,types=types,annotate=args.annotate)

    def generate_swift_reverse_file(self):
        swift_dir = self.args.swiftdir
        swift_file_name = os.path.join( swift_dir, 'rzfit_swift_reverse_map.swift' )
        
        logging.info( 'Writing {}'.format( swift_file_name ) )
        oof = open( swift_file_name, 'w' )

        rv =  [
            '// This file is auto generated, Do not edit',
            '',
            'import FitFileParserObjc'
        ]

        rv.extend( self.context.swift_func_reverse_value() )
        
        for (n,m) in self.context.messages.items():
            rv.extend( m.swift_func_reverse_value(self.context) )
            
        for one in self.context.types.values():
            rv.extend(  one.swift_func_reverse_value() )
        
        oof.write( '\n'.join( rv ) )
        
    def generate_swift_file(self):
        swift_dir = self.args.swiftdir
        swift_file_name = os.path.join( swift_dir, 'rzfit_swift_map.swift' )
        
        logging.info( 'Writing {}'.format( swift_file_name ) )
        oof = open( swift_file_name, 'w' )

        rv =  [
            '// This file is auto generated, Do not edit',
            '',
            'import FitFileParserObjc'
        ]

        if os.path.isfile( 'fitsdkversion.txt' ):
            with open( 'fitsdkversion.txt', 'r' ) as vf:
                version = vf.readline().rstrip()
            rv.extend( [
                '',
                'extension FitFile {',
                '  public static let sdkVersion = "{}"'.format( version ),
                '}'
                ] )
        
        rv.extend( [
            '',
            '//MARK: - Module Entry Point Functions',
            ''
            ] )
                         
        mesg_num = self.context.types['mesg_num']
        
        rv.extend( self.context.swift_func_build_mesg() )
        rv.extend( self.context.swift_unit_functions() )
        rv.extend( self.context.swift_func_type_to_string() )
        rv.extend( mesg_num.swift_func_from_string(fileprivate=False) )
        rv.extend( mesg_num.swift_func_to_string(fileprivate=False) )
        
        rv.append( '// MARK: - Extension' )
        
        rv.extend( mesg_num.swift_stmt_extension('FitMessageType' ) )
        rv.extend( [
            '',
            '//MARK: - convertion fittype to string functions',
            ''
            ] )

        for one in self.context.types.values():
            if one.name != 'mesg_num':
                rv.extend(  one.swift_func_to_string() )
                if one.is_masked_value:
                    rv.extend( one.swift_func_to_value() )
        
        rv.extend( [
            '',
            '//MARK: - fit convert structure to dict',
            ''
            ] )
        
        for (n,m) in self.context.messages.items():
            rv.extend( m.swift_func_field_num_to_string(self.context) )

        rv.extend( self.context.swift_func_field_num_to_string() )
        
        rv.extend( [
            '',
            '//MARK: - fit build messages dict ',
            ''
            ] )
        rv.extend( self.context.swift_func_messages_dict() )

        
        oof.write( '\n'.join( rv ) )

    def generate_objc_mesg_def(self):
        objc_dir = self.args.objcdir
        objc_file_name = os.path.join( objc_dir, 'rzfit_objc_reference_mesg.m' )
        objc_header = 'rzfit_objc_reference_mesg.h'
        objc_header_name = os.path.join( objc_dir, objc_header )
        logging.info( 'Writing {}'.format( objc_file_name ) )
        oof = open( objc_file_name, 'w')
        
        rv = [
            '// This file is auto generated, Do not edit',
            '',
            '#include "{}"'.format( objc_header ),
            '',
        ]
        messages = self.context.arg_messages()
        for m in messages:
            rv.extend( m.objc_mesg_def(self.context) )
            
        rv.extend( self.context.objc_fit_mesg_defs() )

        oof.write( '\n'.join( rv ) )

        logging.info( 'Writing {}'.format( objc_header_name ) )
        ooh = open( objc_header_name, 'w')
        
        rv = [
            '// This file is auto generated, Do not edit',
            '#pragma once',
            '#include "fit.h"',
            '',
            '',
        ]
        rv.extend( self.context.objc_fit_mesg_defs_forward_declare() )

        # types that are useful to define
        rv.extend( self.context.types['mesg_num'].objc_typedef() )
        rv.extend( self.context.types['fit_base_type'].objc_typedef() )
        messages = self.context.arg_messages()
        for m in messages:
            rv.extend( m.objc_mesg_struct(self.context) )

        ooh.write( '\n'.join( rv ) )

    def generate_objc_file(self):
        objc_dir = self.args.objcdir
        objc_file_name = os.path.join( objc_dir, 'rzfit_objc_map.m' )
        objc_header = 'rzfit_objc_map.h'
        
        logging.info( 'Writing {}'.format( objc_file_name ) )
        
        oof = open( objc_file_name, 'w')

        rv = [
            '// This file is auto generated, Do not edit',
            '',
            '@import Foundation;',
            '#include "{}"'.format( objc_header ),
            ''
            '#pragma mark - types conversion section\n',
        ]
                         
        for (n,t) in self.context.types.items():
            if t.name != 'mesg_num':
                rv.extend( t.objc_func_to_string() )

        rv.append( '#pragma mark - message field info' )
        
        for (n,m) in self.context.messages.items():
            rv.extend( m.objc_func_field_info(self.context) )

        rv.append( '#pragma mark - message field name conversion section' )

        for (n,m) in self.context.messages.items():
            rv.extend( m.objc_func_field_num_to_string(self.context) )

        rv.append( '#pragma mark - public section' )

        rv.extend( self.context.types['mesg_num'].objc_func_to_string(fileprivate=False) )
        rv.extend( self.context.objc_func_unit_to_string() )
        rv.extend( self.context.objc_func_field_num_to_string() )
        rv.extend( self.context.objc_func_type_to_string() )
        rv.extend( self.context.objc_func_field_info() )

        oof.write( '\n'.join( rv ) )

    def cmd_generate(self):
        self.generate_objc_mesg_def()
        self.generate_objc_file()
        self.generate_swift_file()
        self.generate_swift_reverse_file()
        
    def cmd_message(self):
        messages = self.context.arg_messages()
        for m in messages:
            print( m )
            if self.args.message:
                fields = self.context.arg_fields(m)
                for f in fields:
                    if self.args.field:
                        print( f.description() )
                    else:
                        print( f )
    def cmd_type(self):
        types = self.context.arg_types()
        for t in types:
            if self.args.type:
                print( t.description() )
            else:
                print( t )
        
if __name__ == "__main__":
    commands = {
        'message':{'attr':'cmd_message','help':'Show message information'},
        'type':{'attr':'cmd_type','help':'Show type information'},
        'generate':{'attr':'cmd_generate','help':'Generate swift and objective c files'},
    }
    
    description = "\n".join( [ '  {}: {}'.format( k,v['help'] ) for (k,v) in commands.items() ] )
    
    parser = argparse.ArgumentParser( description='Auto Generate Parser files', formatter_class=argparse.RawTextHelpFormatter )

    parser.add_argument( 'command', metavar='Command', help = 'command to execute:\n' + description )
    parser.add_argument( 'profile', default = 'Profile.xlsx' )
    parser.add_argument( '-a', '--annotate',   action='store_true', default=False, help = 'Annotate source code with generating code location info' )
    parser.add_argument( '-o', '--objcdir',   default = '../Sources/FitFileParserObjc' )
    parser.add_argument( '-s', '--swiftdir',  default = '../Sources/FitFileParser' )
    parser.add_argument( '-m', '--message',  default = None , help = 'messages separated by + as string or message number')
    parser.add_argument( '-t', '--type',  default = None, help = 'types separated by + as string or type number' )
    parser.add_argument( '-f', '--field',  default = None, help = 'field separated by + as string or field number' )
    parser.add_argument( '-q', '--quiet',  default=False, action='store_true' )
    parser.add_argument( '-d', '--debug',  default=False, action='store_true', help = 'print extra debug information on the message or field selected' )
    args = parser.parse_args()

    command = Command( args )
    
    if args.command in commands:
        getattr(command,commands[args.command]['attr'])()
    else:
        logging.error( 'Invalid command "{}"'.format( args.command) )
        parser.print_help()
