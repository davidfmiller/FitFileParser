#!/usr/bin/env python3

# download latest fit sdk from https://developer.garmin.com/fitconv
#
# This will copy the profile, update the version.txt and update the fit sdk c source code comment with the latest version information
# After the update, run fitsdkparser.py to regenerage the code with the updated profile
#
# run utility against that directory
#     ./fitsdkupdate.py /path/to/FitSDKRElease_20.XX.00

import re
import subprocess
import argparse
import hashlib
import os
import shutil

def file_fix_crlf(file_path):
    with open( file_path, 'rb' ) as of:
        content = of.read()
    pre = len( content )
    content = content.replace(  b'\r\n', b'\n' )
    post = len( content )
    if pre != post:
        print( 'fixed {}'.format( file_path ) )
    with open( file_path, 'wb' ) as open_file:
        open_file.write( content )

def file_hash(filepath):
    openedFile = open(filepath, 'rb')
    readFile = openedFile.read()

    hash = hashlib.sha1(readFile)
    return hash.hexdigest()

def update_version(fn_from,fn_to,execute=False):
    patterns = {
        'copyright' : re.compile( '// Copyright ([0-9]+) Garmin Canada' ),
        'profile'   : re.compile( '// Profile Version = ([0-9.]+)' ),
        'tag'       : re.compile( '// Tag = production/' ),
        'def_minor' : re.compile( ' +#define FIT_PROFILE_VERSION_MINOR +([0-9]+)' ),
        'def_major' : re.compile( ' +#define FIT_PROFILE_VERSION_MAJOR +([0-9]+)' ),
        }
    
    version = None

    values = {}
    f_i = open(fn_from, 'r')

    for line in f_i:
        if line.startswith( '//' ) or 'FIT_PROFILE_VERSION' in line:
            for k,v in patterns.items():
                m = v.match( line )
                if m:
                    values[k] = line
                    if k == 'profile':
                        version = m[1]

    fn_to_w = fn_to + '~'
                    
    f_o = open(fn_to, 'r')
    f_o_w = open( fn_to_w, 'w')

    changed = False
    
    for line in f_o:
        wrote = False
        if line.startswith( '//' ) or 'FIT_PROFILE_VERSION' in line:
            for k,v in patterns.items():
                if k in values:
                    if v.match( line ):
                        if values[k] != line:
                            changed = True
                        f_o_w.write(values[k])
                        wrote = True
        if not wrote:
            f_o_w.write(line)

    if changed:
        fn_to_tmp = fn_to_w + '~TMP'
        if os.path.exists( fn_to_tmp ):
            os.remove( fn_to_tmp )

        print( 'Update {} to {}'.format( os.path.basename( fn_to ), fn_to_w ) )
        os.rename( fn_to, fn_to_tmp )
        os.rename( fn_to_w, fn_to )
        os.rename( fn_to_tmp, fn_to_w )
    else:
        print( 'Already updated {} from {}'.format( os.path.basename( fn_to ), fn_from ) )

    return version

def do_copy( f_from, f_to, execute = False ):
    rv = False
    if file_hash(f_from) != file_hash( f_to ):
        rv = True
        print( 'cp {} {}'.format( f_from, f_to ) )
        shutil.copyfile( f_from, f_to )
    else:
        print( 'Unchanged {} from {}'.format( f_to, f_from ) )
            
        
def check_diffs(args):
    if os.path.isdir( args.sdkpath ):
        print( 'Checking {}'.format(args.sdkpath) )

        files_to_update = [ ]
        # these are autogenerated and not in the sdk
        skip = [ ]
        
        files = os.listdir( args.output )
        files.extend( [ os.path.join( 'include', x ) for x in  os.listdir( os.path.join( args.output, 'include'  ) ) ] )

        version = None
        
        for f in files:
            f_to   = os.path.join( args.output, f )
            f_from = os.path.join( args.sdkpath, 'c/'+os.path.basename(f).replace( '.m', '.c' ) )
            
            if f.endswith( '~' ) or f in skip or os.path.islink( f_to ) or os.path.isdir( f_to ) or f.startswith( 'rzfit_' ) or f.startswith( 'Fit' ):
                continue
            if os.path.isfile( f_from ) and os.path.isfile( f_to ):
                file_fix_crlf(f_from)
                file_fix_crlf(f_to)
                found = update_version(f_from, f_to, True )
                if found:
                    version = found
                    
                if args.diff and file_hash(f_from) != file_hash( f_to ):
                    subprocess.call( [ 'ksdiff', '--partial-changeset',f_from, f_to ]  )
            else:
                print( 'missing {} {}'.format( f_from, f_to ) )

                
        profile_from = os.path.join( args.sdkpath, 'Profile.xlsx' )
        profile_to   = 'Profile.xlsx'
        
        if os.path.isfile( profile_from ) and os.path.isfile( profile_to ):
            do_copy( profile_from, profile_to, True )

        if version:
            with open( 'fitsdkversion.txt', 'r') as vf:
                oldversion = vf.readline().rstrip()

            if oldversion == version:
                print( f'Same version {version}' )
                print( f'You can run "fitsdkparser.py generate Profile.xls" but no changes are expected' )
            else:
                print( f'Save fitsdkversion.txt with {version} from {oldversion}' )
                with open( 'fitsdkversion.txt', 'w' ) as of:
                    of.write( version )
                print( f'You can run "fitsdkparser.py generate Profile.xls" to update the code with latest version' )
if __name__ == "__main__":
    parser = argparse.ArgumentParser( description='diff with sdk' )
    parser.add_argument( 'sdkpath' )
    parser.add_argument( '-v', '--verbose', action='store_true' )
    parser.add_argument( '-d', '--diff', action='store_true', help='start ksdiff to look at diff' )
    parser.add_argument( '-o', '--output', default='../Sources/FitFileParserObjc' )
    args = parser.parse_args()

    check_diffs( args )


